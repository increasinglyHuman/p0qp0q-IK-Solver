<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p0qp0q-IK-Solver - Universal Auto-Constraint Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Space Mono', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.95);
            padding: 20px;
            border-radius: 8px;
            max-width: 450px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        #info h1 {
            margin: 0 0 15px 0;
            color: #ff00ff;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }
        #info h2 {
            margin: 15px 0 10px 0;
            color: #00aaff;
            font-size: 16px;
        }
        #info code {
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            color: #00ff00;
            font-size: 12px;
        }
        #info .status {
            background: #2a2a2a;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 8px 0;
            border-left: 3px solid #00ff00;
        }
        #info .status.warning {
            border-left-color: #ff9900;
        }
        #info .status.error {
            border-left-color: #ff0000;
        }
        #info ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        #info li {
            margin: 4px 0;
            font-size: 13px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>p0qp0q Universal IK</h1>
        <p><strong>The World's First Truly Universal IK Solver</strong></p>

        <h2>ðŸŽ¯ Auto-Detection Status:</h2>
        <div id="platform-status" class="status">Loading model...</div>
        <div id="axis-status" class="status">Waiting for platform...</div>
        <div id="constraint-status" class="status">Waiting for axis...</div>

        <h2>âœ¨ What Makes This Special:</h2>
        <ul>
            <li>âœ… <strong>Automatic axis detection</strong> - No manual config!</li>
            <li>âœ… <strong>Universal platform support</strong> - Works on ANY rig</li>
            <li>âœ… <strong>Medical-grade constraints</strong> - Anatomically accurate</li>
            <li>âœ… <strong>No Â±180Â° wraparound</strong> - Quaternion magic!</li>
            <li>âœ… <strong>Scale-aware</strong> - 0.01 to 100+ scale models</li>
        </ul>

        <h2>ðŸŽ® Controls:</h2>
        <p><strong>Drag</strong> red/pink spheres to move hands/feet</p>
        <p><strong>Orbit:</strong> Left mouse button</p>
        <p><strong>Pan:</strong> Right mouse button</p>
        <p><strong>Zoom:</strong> Scroll wheel</p>

        <div id="joint-info" style="margin-top: 15px; font-size: 12px; opacity: 0.8;">
            <strong>Left Knee:</strong> <span id="left-knee">-</span><br>
            <strong>Right Knee:</strong> <span id="right-knee">-</span><br>
            <strong>Left Elbow:</strong> <span id="left-elbow">-</span><br>
            <strong>Right Elbow:</strong> <span id="right-elbow">-</span>
        </div>
    </div>

    <div id="loading" class="loading">
        Loading p0qp0q Universal IK System...
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // Import our packages (using relative paths for now)
        import { P0qP0qIKSolver } from '../p0qp0q-IK-Solver.js';
        import {
            BoneAxisDetector,
            BoneMapper,
            ConstraintHelper,
            BiomechanicalData
        } from '../../p0qp0q-animation-utils/src/index.js';

        console.log('ðŸš€ p0qp0q Universal IK System - Auto-Constraint Demo');
        console.log('======================================================');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 5, 15);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(2, 1.5, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);

        const directional = new THREE.DirectionalLight(0xffffff, 1.0);
        directional.position.set(5, 10, 5);
        directional.castShadow = true;
        scene.add(directional);

        // Grid
        const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(grid);

        // Controls
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.target.set(0, 1, 0);
        orbitControls.update();

        // Initialize our utilities
        const boneMapper = new BoneMapper();
        const axisDetector = new BoneAxisDetector();

        // State
        let ikSolver = null;
        let skinnedMesh = null;
        let ikTargets = [];
        let transformControls = [];

        // Load the test model
        const loader = new GLTFLoader();
        loader.load(
            './models/test-character.glb',
            (gltf) => {
                console.log('âœ… Model loaded');

                // Find skinned mesh
                gltf.scene.traverse((child) => {
                    if (child.isSkinnedMesh) {
                        skinnedMesh = child;
                    }
                });

                if (!skinnedMesh) {
                    console.error('âŒ No skinned mesh found in model');
                    return;
                }

                scene.add(gltf.scene);

                // Hide loading
                document.getElementById('loading').style.display = 'none';

                // STEP 1: Detect platform
                const bones = skinnedMesh.skeleton.bones;
                const mapping = boneMapper.getBoneMapping(bones);

                updateStatus('platform-status',
                    `Platform: ${mapping.platformName || 'Unknown (fuzzy matching)'} - ${Object.keys(mapping.bones).length} bones mapped`,
                    'success');

                console.log('ðŸ—ºï¸  Bone Mapping:', mapping);

                // STEP 2: Detect axes for key joints
                const detectedAxes = {};
                const joints = ['leftLowerLeg', 'rightLowerLeg', 'leftLowerArm', 'rightLowerArm'];

                joints.forEach(jointName => {
                    const bone = mapping.bones[jointName];
                    if (bone) {
                        detectedAxes[jointName] = axisDetector.detectPrimaryAxis(bone);
                    }
                });

                updateStatus('axis-status',
                    `Axes detected: ${Object.keys(detectedAxes).length}/4 joints - Confidence: ${Math.round(Object.values(detectedAxes)[0]?.confidence * 100)}%`,
                    'success');

                console.log('ðŸŽ¯ Detected Axes:', detectedAxes);

                // STEP 3: Create constraints automatically
                const constraints = {};

                // Knees
                if (detectedAxes.leftLowerLeg) {
                    constraints.leftKnee = ConstraintHelper.createFromBiomechanics('knee', detectedAxes.leftLowerLeg.direction);
                }
                if (detectedAxes.rightLowerLeg) {
                    constraints.rightKnee = ConstraintHelper.createFromBiomechanics('knee', detectedAxes.rightLowerLeg.direction);
                }

                // Elbows
                if (detectedAxes.leftLowerArm) {
                    constraints.leftElbow = ConstraintHelper.createFromBiomechanics('elbow', detectedAxes.leftLowerArm.direction);
                }
                if (detectedAxes.rightLowerArm) {
                    constraints.rightElbow = ConstraintHelper.createFromBiomechanics('elbow', detectedAxes.rightLowerArm.direction);
                }

                updateStatus('constraint-status',
                    `Constraints created: ${Object.keys(constraints).length} joints - Medical-grade ROM applied`,
                    'success');

                console.log('ðŸ§¬ Biomechanical Constraints:', constraints);

                // STEP 4: Setup IK chains
                setupIK(mapping, constraints);
            },
            (progress) => {
                const percent = (progress.loaded / progress.total) * 100;
                document.getElementById('loading').textContent =
                    `Loading... ${percent.toFixed(0)}%`;
            },
            (error) => {
                console.error('âŒ Load error:', error);
                updateStatus('platform-status', 'Failed to load model', 'error');
            }
        );

        function setupIK(mapping, constraints) {
            const bones = skinnedMesh.skeleton.bones;
            const boneIndices = new Map();
            bones.forEach((bone, i) => boneIndices.set(bone.uuid, i));

            const iks = [];

            // Left leg chain
            if (mapping.bones.leftFoot && mapping.bones.leftLowerLeg) {
                iks.push({
                    target: createIKTarget(mapping.bones.leftFoot, 0xff0000, 0),
                    effector: boneIndices.get(mapping.bones.leftFoot.uuid),
                    iteration: 10,
                    links: [
                        {
                            index: boneIndices.get(mapping.bones.leftLowerLeg.uuid),
                            swingTwistConstraint: constraints.leftKnee
                        },
                        {
                            index: boneIndices.get(mapping.bones.leftUpperLeg.uuid)
                        }
                    ]
                });
            }

            // Right leg chain
            if (mapping.bones.rightFoot && mapping.bones.rightLowerLeg) {
                iks.push({
                    target: createIKTarget(mapping.bones.rightFoot, 0xff69b4, 1),
                    effector: boneIndices.get(mapping.bones.rightFoot.uuid),
                    iteration: 10,
                    links: [
                        {
                            index: boneIndices.get(mapping.bones.rightLowerLeg.uuid),
                            swingTwistConstraint: constraints.rightKnee
                        },
                        {
                            index: boneIndices.get(mapping.bones.rightUpperLeg.uuid)
                        }
                    ]
                });
            }

            console.log('ðŸ”— Created IK chains:', iks.length);

            // Create solver
            ikSolver = new P0qP0qIKSolver(skinnedMesh, iks);

            console.log('âœ… IK Solver initialized!');
            console.log('ðŸ“Š Detected scale:', ikSolver._detectModelScale().toFixed(4));
            console.log('ðŸŽ¯ Ready to drag targets!');
        }

        function createIKTarget(bone, color, index) {
            const geo = new THREE.SphereGeometry(0.08);
            const mat = new THREE.MeshBasicMaterial({
                color,
                transparent: true,
                opacity: 0.8
            });
            const target = new THREE.Mesh(geo, mat);

            // Position at bone
            bone.getWorldPosition(target.position);
            scene.add(target);

            // Make draggable
            const tc = new TransformControls(camera, renderer.domElement);
            tc.attach(target);
            tc.setMode('translate');
            tc.setSize(0.8);
            scene.add(tc);

            tc.addEventListener('dragging-changed', (e) => {
                orbitControls.enabled = !e.value;
            });

            ikTargets.push(target);
            transformControls.push(tc);

            return skinnedMesh.skeleton.bones.length - (ikTargets.length - 1) - 1;
        }

        function updateStatus(elementId, message, type = 'success') {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = type === 'error' ? 'status error' :
                          type === 'warning' ? 'status warning' : 'status';
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (ikSolver && ikTargets.length > 0) {
                // Update target bone positions
                ikTargets.forEach((target, i) => {
                    const targetBone = skinnedMesh.skeleton.bones[
                        skinnedMesh.skeleton.bones.length - ikTargets.length + i
                    ];
                    targetBone.position.copy(target.position);
                    targetBone.updateMatrixWorld(true);
                });

                // Solve IK!
                ikSolver.update();

                // Update joint angle displays
                // (You can add more detailed tracking here)
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
